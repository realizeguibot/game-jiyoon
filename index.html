<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>They Watch</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
        #renderCanvas { width: 100%; height: 100%; touch-action: none; display: block; }
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.92); z-index: 10; cursor: pointer;
            font-family: 'Courier New', monospace;
        }
        #overlay h1 {
            color: #8b0000; font-size: min(4em, 10vw); letter-spacing: min(12px, 2vw);
            text-shadow: 0 0 20px #8b0000, 0 0 40px #5a0000;
            animation: flicker 3s infinite;
        }
        #overlay p { color: #666; font-size: min(1.1em, 3.5vw); margin-top: 20px; text-align: center; padding: 0 20px; }
        #overlay .hint { color: #444; font-size: min(0.8em, 3vw); margin-top: 40px; }
        #version { color: #333; font-size: min(0.7em, 2.5vw); margin-top: 50px; }
        @keyframes flicker {
            0%, 95%, 100% { opacity: 1; }
            96% { opacity: 0.3; }
            97% { opacity: 0.8; }
            98% { opacity: 0.2; }
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 2px; height: 2px; background: rgba(200,200,200,0.3);
            box-shadow: 0 -8px 0 rgba(200,200,200,0.3), 0 8px 0 rgba(200,200,200,0.3),
                        -8px 0 0 rgba(200,200,200,0.3), 8px 0 0 rgba(200,200,200,0.3);
            z-index: 5; display: none; pointer-events: none;
        }
        #vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 4; display: none;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.7) 100%);
        }
        #warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #8b0000; font-family: 'Courier New', monospace; font-size: min(1.5em, 5vw);
            pointer-events: none; z-index: 6; opacity: 0; display: none;
            text-shadow: 0 0 10px #8b0000;
        }

        /* Floating joystick (rendered via canvas overlay) */
        #touchLayer {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none;
        }
        #touchLayerCanvas {
            width: 100%; height: 100%; pointer-events: auto; touch-action: none;
        }
        #sprintBtn {
            position: absolute; bottom: 30px; right: 30px;
            width: 70px; height: 70px; border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.3); pointer-events: auto;
            display: none; align-items: center; justify-content: center;
            font-family: 'Courier New', monospace; color: rgba(255,255,255,0.3);
            font-size: 11px; text-transform: uppercase; z-index: 6;
        }
        #sprintBtn.active {
            border-color: rgba(139,0,0,0.6); background: rgba(139,0,0,0.25);
            color: rgba(255,255,255,0.6);
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="overlay">
        <h1>THEY WATCH</h1>
        <p>You are not alone in this city.</p>
        <p style="color:#555; font-size:min(0.9em,3vw); margin-top:10px;">They see you. They always see you.</p>
        <p class="hint">Tap to begin</p>
        <p class="hint" style="margin-top:10px; color:#333;" id="controlsHint"></p>
        <p id="version">v0.4</p>
    </div>
    <div id="crosshair"></div>
    <div id="vignette"></div>
    <div id="warning">they're closer now</div>

    <div id="touchLayer"><canvas id="touchLayerCanvas"></canvas></div>
    <div id="sprintBtn">RUN</div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const overlay = document.getElementById("overlay");
        const crosshair = document.getElementById("crosshair");
        const vignette = document.getElementById("vignette");
        const warningEl = document.getElementById("warning");
        const touchLayer = document.getElementById("touchLayer");
        const touchCanvas = document.getElementById("touchLayerCanvas");
        const touchCtx = touchCanvas.getContext("2d");
        const sprintBtn = document.getElementById("sprintBtn");
        const controlsHint = document.getElementById("controlsHint");

        // Detect mobile / touch device
        const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;

        controlsHint.textContent = isMobile
            ? "Left side: move \u2022 Right side: look \u2022 RUN to sprint"
            : "WASD to move \u2022 Mouse to look \u2022 Shift to run";

        const engine = new BABYLON.Engine(canvas, true, { stencil: true, preserveDrawingBuffer: true, premultipliedAlpha: false });

        // === AUDIO ===
        let audioCtx = null;
        let ambiencePlaying = false;

        function startAmbience() {
            if (ambiencePlaying) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const gain = audioCtx.createGain();
            gain.gain.value = 0.06;
            gain.connect(audioCtx.destination);

            const osc1 = audioCtx.createOscillator();
            osc1.type = "sawtooth"; osc1.frequency.value = 38;
            const f1 = audioCtx.createBiquadFilter(); f1.type = "lowpass"; f1.frequency.value = 80;
            osc1.connect(f1); f1.connect(gain); osc1.start();

            const osc2 = audioCtx.createOscillator();
            osc2.type = "sine"; osc2.frequency.value = 22;
            const g2 = audioCtx.createGain(); g2.gain.value = 0.4;
            osc2.connect(g2); g2.connect(gain); osc2.start();

            const osc3 = audioCtx.createOscillator();
            osc3.type = "sine"; osc3.frequency.value = 440;
            const g3 = audioCtx.createGain(); g3.gain.value = 0.008;
            const f3 = audioCtx.createBiquadFilter(); f3.type = "bandpass"; f3.frequency.value = 440; f3.Q.value = 30;
            osc3.connect(f3); f3.connect(g3); g3.connect(gain); osc3.start();
            const lfo = audioCtx.createOscillator(); lfo.frequency.value = 0.1;
            const lg = audioCtx.createGain(); lg.gain.value = 5;
            lfo.connect(lg); lg.connect(osc3.frequency); lfo.start();

            ambiencePlaying = true;
        }

        function playFootstep() {
            if (!audioCtx) return;
            const b = audioCtx.createBufferSource();
            const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2-1) * Math.exp(-i/(d.length*0.15));
            b.buffer = buf;
            const g = audioCtx.createGain(); g.gain.value = 0.08;
            const f = audioCtx.createBiquadFilter(); f.type = "lowpass"; f.frequency.value = 600;
            b.connect(f); f.connect(g); g.connect(audioCtx.destination); b.start();
        }

        function playScaryStinger() {
            if (!audioCtx) return;
            const o = audioCtx.createOscillator(); o.type = "sawtooth"; o.frequency.value = 200+Math.random()*300;
            const g = audioCtx.createGain(); g.gain.value = 0.12;
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime+1.5);
            const f = audioCtx.createBiquadFilter(); f.type = "bandpass"; f.frequency.value = 800; f.Q.value = 5;
            o.connect(f); f.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime+1.5);
        }

        function playWhisper() {
            if (!audioCtx) return;
            const b = audioCtx.createBufferSource();
            const len = audioCtx.sampleRate * 2;
            const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const d = buf.getChannelData(0);
            for (let i = 0; i < len; i++) d[i] = (Math.random()*2-1) * Math.sin((i/len)*Math.PI) * 0.03;
            b.buffer = buf;
            const f = audioCtx.createBiquadFilter(); f.type = "bandpass"; f.frequency.value = 2000+Math.random()*1000; f.Q.value = 8;
            b.connect(f);
            const g = audioCtx.createGain(); g.gain.value = 0.5;
            f.connect(g); g.connect(audioCtx.destination); b.start();
        }

        // === TOUCH INPUT STATE ===
        let touchMoveX = 0, touchMoveZ = 0;
        let touchLookDX = 0, touchLookDY = 0;
        let sprinting = false;

        // Floating joystick state
        let joystickActive = false;
        let joystickTouchId = null;
        let joystickBaseX = 0, joystickBaseY = 0; // center of base (screen coords)
        let joystickThumbX = 0, joystickThumbY = 0;
        const joystickRadius = 60;
        const joystickThumbRadius = 25;

        // Look touch state
        let lookTouchId = null;
        let lastLookX = 0, lastLookY = 0;

        function resizeTouchCanvas() {
            touchCanvas.width = window.innerWidth;
            touchCanvas.height = window.innerHeight;
        }

        function drawJoystick() {
            touchCtx.clearRect(0, 0, touchCanvas.width, touchCanvas.height);
            if (!joystickActive) return;

            // Base circle
            touchCtx.beginPath();
            touchCtx.arc(joystickBaseX, joystickBaseY, joystickRadius, 0, Math.PI * 2);
            touchCtx.strokeStyle = "rgba(255,255,255,0.2)";
            touchCtx.lineWidth = 2;
            touchCtx.fillStyle = "rgba(0,0,0,0.25)";
            touchCtx.fill();
            touchCtx.stroke();

            // Thumb
            touchCtx.beginPath();
            touchCtx.arc(joystickThumbX, joystickThumbY, joystickThumbRadius, 0, Math.PI * 2);
            touchCtx.fillStyle = "rgba(255,255,255,0.25)";
            touchCtx.fill();
        }

        function setupTouchControls() {
            resizeTouchCanvas();
            window.addEventListener("resize", resizeTouchCanvas);

            const halfW = () => window.innerWidth / 2;

            touchCanvas.addEventListener("touchstart", (e) => {
                e.preventDefault();
                for (const t of e.changedTouches) {
                    if (t.clientX < halfW() && joystickTouchId === null) {
                        // Left side -> joystick
                        joystickTouchId = t.identifier;
                        joystickActive = true;
                        joystickBaseX = t.clientX;
                        joystickBaseY = t.clientY;
                        joystickThumbX = t.clientX;
                        joystickThumbY = t.clientY;
                        touchMoveX = 0;
                        touchMoveZ = 0;
                    } else if (t.clientX >= halfW() && lookTouchId === null) {
                        // Right side -> look
                        lookTouchId = t.identifier;
                        lastLookX = t.clientX;
                        lastLookY = t.clientY;
                    }
                }
            }, { passive: false });

            touchCanvas.addEventListener("touchmove", (e) => {
                e.preventDefault();
                for (const t of e.changedTouches) {
                    if (t.identifier === joystickTouchId) {
                        let dx = t.clientX - joystickBaseX;
                        let dy = t.clientY - joystickBaseY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist > joystickRadius) {
                            dx = dx / dist * joystickRadius;
                            dy = dy / dist * joystickRadius;
                        }
                        joystickThumbX = joystickBaseX + dx;
                        joystickThumbY = joystickBaseY + dy;
                        touchMoveX = dx / joystickRadius;
                        touchMoveZ = dy / joystickRadius;
                    } else if (t.identifier === lookTouchId) {
                        touchLookDX += (t.clientX - lastLookX);
                        touchLookDY += (t.clientY - lastLookY);
                        lastLookX = t.clientX;
                        lastLookY = t.clientY;
                    }
                }
            }, { passive: false });

            const endTouch = (e) => {
                for (const t of e.changedTouches) {
                    if (t.identifier === joystickTouchId) {
                        joystickTouchId = null;
                        joystickActive = false;
                        touchMoveX = 0;
                        touchMoveZ = 0;
                    }
                    if (t.identifier === lookTouchId) {
                        lookTouchId = null;
                    }
                }
            };
            touchCanvas.addEventListener("touchend", endTouch);
            touchCanvas.addEventListener("touchcancel", endTouch);

            // Sprint button
            sprintBtn.addEventListener("touchstart", (e) => {
                e.preventDefault(); e.stopPropagation();
                sprinting = true; sprintBtn.classList.add("active");
            }, { passive: false });
            sprintBtn.addEventListener("touchend", () => { sprinting = false; sprintBtn.classList.remove("active"); });
            sprintBtn.addEventListener("touchcancel", () => { sprinting = false; sprintBtn.classList.remove("active"); });

            // Draw loop for joystick
            function drawLoop() {
                drawJoystick();
                requestAnimationFrame(drawLoop);
            }
            drawLoop();
        }

        // === SCENE ===
        const createScene = () => {
            const scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.04, 0.04, 0.07);
            scene.ambientColor = new BABYLON.Color3(0.1, 0.1, 0.12);
            scene.gravity = new BABYLON.Vector3(0, -0.7, 0);
            scene.collisionsEnabled = true;

            // Fog - lighter, less dense
            scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;
            scene.fogDensity = 0.012;
            scene.fogColor = new BABYLON.Color3(0.04, 0.04, 0.07);

            // Camera
            const camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 1.7, 0), scene);
            camera.minZ = 0.1;
            camera.ellipsoid = new BABYLON.Vector3(0.4, 0.85, 0.4);
            camera.checkCollisions = true;
            camera.applyGravity = true;

            if (isMobile) {
                camera.inputs.clear();
            } else {
                camera.attachControl(canvas, true);
                camera.speed = 0.3;
                camera.angularSensibility = 3000;
                camera.inertia = 0.82;
                camera.keysUp = [87]; camera.keysDown = [83];
                camera.keysLeft = [65]; camera.keysRight = [68];
            }

            if (!isMobile) {
                window.addEventListener("keydown", e => { if (e.key === "Shift") { sprinting = true; camera.speed = 0.55; } });
                window.addEventListener("keyup", e => { if (e.key === "Shift") { sprinting = false; camera.speed = 0.3; } });
            }

            // === MATERIALS ===
            const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
            groundMat.diffuseColor = new BABYLON.Color3(0.25, 0.24, 0.22);
            groundMat.specularColor = new BABYLON.Color3(0.03, 0.03, 0.03);

            const roadMat = new BABYLON.StandardMaterial("roadMat", scene);
            roadMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            roadMat.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);

            const buildingMat = new BABYLON.StandardMaterial("buildMat", scene);
            buildingMat.diffuseColor = new BABYLON.Color3(0.3, 0.28, 0.32);
            buildingMat.specularColor = BABYLON.Color3.Black();

            const darkBuildMat = new BABYLON.StandardMaterial("darkBuild", scene);
            darkBuildMat.diffuseColor = new BABYLON.Color3(0.2, 0.19, 0.22);
            darkBuildMat.specularColor = BABYLON.Color3.Black();

            const windowMat = new BABYLON.StandardMaterial("winMat", scene);
            windowMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.03);
            windowMat.emissiveColor = new BABYLON.Color3(0.5, 0.4, 0.15);
            windowMat.specularColor = BABYLON.Color3.Black();

            const windowDarkMat = new BABYLON.StandardMaterial("winDarkMat", scene);
            windowDarkMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.05);
            windowDarkMat.specularColor = BABYLON.Color3.Black();

            const sidewalkMat = new BABYLON.StandardMaterial("sidewalkMat", scene);
            sidewalkMat.diffuseColor = new BABYLON.Color3(0.3, 0.28, 0.27);
            sidewalkMat.specularColor = BABYLON.Color3.Black();

            const pupilMat = new BABYLON.StandardMaterial("pupilMat", scene);
            pupilMat.diffuseColor = new BABYLON.Color3(0.02, 0.02, 0.02);
            pupilMat.specularColor = BABYLON.Color3.Black();

            // Ground
            const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 120, height: 120 }, scene);
            ground.material = groundMat;
            ground.checkCollisions = true;

            // City layout
            const blockSize = 14, roadWidth = 6;
            const cellSize = blockSize + roadWidth;
            const gridCount = 5;
            const offset = -(gridCount * cellSize) / 2 + cellSize / 2;

            for (let i = 0; i < gridCount; i++) {
                const z = offset + i * cellSize;
                const road = BABYLON.MeshBuilder.CreateGround("rH"+i, { width: gridCount*cellSize+roadWidth, height: roadWidth }, scene);
                road.position.y = 0.01; road.position.z = z; road.material = roadMat;
                const road2 = BABYLON.MeshBuilder.CreateGround("rV"+i, { width: roadWidth, height: gridCount*cellSize+roadWidth }, scene);
                road2.position.y = 0.01; road2.position.x = offset+i*cellSize; road2.material = roadMat;
            }

            for (let i = 0; i < gridCount; i++) {
                for (let side = -1; side <= 1; side += 2) {
                    const z = offset + i*cellSize + side*(roadWidth/2+0.5);
                    const sw = BABYLON.MeshBuilder.CreateGround("swH"+i+side, { width: gridCount*cellSize, height: 1 }, scene);
                    sw.position.y = 0.05; sw.position.z = z; sw.material = sidewalkMat;
                    const x = offset + i*cellSize + side*(roadWidth/2+0.5);
                    const sw2 = BABYLON.MeshBuilder.CreateGround("swV"+i+side, { width: 1, height: gridCount*cellSize }, scene);
                    sw2.position.y = 0.05; sw2.position.x = x; sw2.material = sidewalkMat;
                }
            }

            let seed = 42;
            function rand() { seed = (seed * 16807) % 2147483647; return seed / 2147483647; }

            // Buildings
            for (let gx = 0; gx < gridCount; gx++) {
                for (let gz = 0; gz < gridCount; gz++) {
                    const cx = offset + gx*cellSize, cz = offset + gz*cellSize;
                    if (gx === 2 && gz === 2) continue; // player spawn
                    const nb = 1 + Math.floor(rand() * 2);
                    for (let b = 0; b < nb; b++) {
                        const bw = 3+rand()*(blockSize-5), bd = 3+rand()*(blockSize-5), bh = 4+rand()*16;
                        const bx = cx+(rand()-0.5)*(blockSize-bw)*0.8, bz = cz+(rand()-0.5)*(blockSize-bd)*0.8;
                        const bld = BABYLON.MeshBuilder.CreateBox("b"+gx+gz+b, {width:bw,height:bh,depth:bd}, scene);
                        bld.position = new BABYLON.Vector3(bx, bh/2, bz);
                        bld.material = rand()>0.5 ? buildingMat : darkBuildMat;
                        bld.checkCollisions = true;

                        const floors = Math.floor(bh / 3);
                        for (let f = 0; f < floors; f++) {
                            const wy = f*3+2;
                            if (wy > bh-1) continue;
                            for (let w = 0; w < Math.floor(bw/2); w++) {
                                if (rand() > 0.35) continue;
                                const wx = bx - bw/2 + 1 + w*2;
                                const isLit = rand() > 0.65;
                                const win = BABYLON.MeshBuilder.CreatePlane("w", {width:0.8,height:1.2}, scene);
                                win.position = new BABYLON.Vector3(wx, wy, bz-bd/2-0.01);
                                win.material = isLit ? windowMat : windowDarkMat;
                                if (rand() > 0.5) {
                                    const w2 = BABYLON.MeshBuilder.CreatePlane("w2", {width:0.8,height:1.2}, scene);
                                    w2.position = new BABYLON.Vector3(wx, wy, bz+bd/2+0.01);
                                    w2.rotation.y = Math.PI;
                                    w2.material = isLit ? windowMat : windowDarkMat;
                                }
                            }
                        }
                    }
                }
            }

            // Street lights - MORE of them, brighter
            const streetLights = [];
            for (let gx = 0; gx < gridCount; gx++) {
                for (let gz = 0; gz < gridCount; gz++) {
                    const cx = offset+gx*cellSize, cz = offset+gz*cellSize;
                    for (let corner = 0; corner < 4; corner++) {
                        if (rand() > 0.65) continue; // more lights spawn now
                        const sx = (corner%2===0?-1:1)*(blockSize/2+1);
                        const sz = (corner<2?-1:1)*(blockSize/2+1);

                        const pole = BABYLON.MeshBuilder.CreateCylinder("p", {height:4.5,diameter:0.12}, scene);
                        pole.position = new BABYLON.Vector3(cx+sx, 2.25, cz+sz);
                        pole.material = darkBuildMat;

                        const lm = new BABYLON.StandardMaterial("lm"+gx+gz+corner, scene);
                        lm.emissiveColor = new BABYLON.Color3(0.8, 0.6, 0.3);
                        lm.diffuseColor = new BABYLON.Color3(0.8, 0.6, 0.3);
                        const lamp = BABYLON.MeshBuilder.CreateSphere("l", {diameter:0.3}, scene);
                        lamp.position = new BABYLON.Vector3(cx+sx, 4.6, cz+sz);
                        lamp.material = lm;

                        const lt = new BABYLON.PointLight("sl"+gx+gz+corner, new BABYLON.Vector3(cx+sx, 4.5, cz+sz), scene);
                        lt.diffuse = new BABYLON.Color3(1.0, 0.8, 0.4);
                        lt.intensity = 2.0;
                        lt.range = 28;

                        streetLights.push({ light: lt, lampMat: lm, baseIntensity: 2.0 });
                    }
                }
            }

            // Hemisphere ambient fill
            const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
            hemi.diffuse = new BABYLON.Color3(0.25, 0.25, 0.35);
            hemi.groundColor = new BABYLON.Color3(0.08, 0.08, 0.1);
            hemi.intensity = 1.2;

            // Directional moonlight - casts light across the whole city
            const moon = new BABYLON.DirectionalLight("moon", new BABYLON.Vector3(-0.5, -1, 0.3), scene);
            moon.diffuse = new BABYLON.Color3(0.45, 0.5, 0.7);
            moon.intensity = 1.8;

            // Player flashlight
            const flashlight = new BABYLON.SpotLight("flash",
                camera.position, camera.getDirection(BABYLON.Vector3.Forward()),
                Math.PI / 3.5, 8, scene);
            flashlight.diffuse = new BABYLON.Color3(0.9, 0.85, 0.7);
            flashlight.intensity = 1.5;
            flashlight.range = 35;

            // === CREEPY PEOPLE ===
            const people = [];
            const personPositions = [];

            for (let gx = 0; gx < gridCount; gx++) {
                for (let gz = 0; gz < gridCount; gz++) {
                    const cx = offset+gx*cellSize, cz = offset+gz*cellSize;
                    const n = Math.floor(rand() * 3);
                    for (let p = 0; p < n; p++) {
                        const a = rand()*Math.PI*2, d = blockSize/2+1+rand()*2;
                        personPositions.push(new BABYLON.Vector3(cx+Math.cos(a)*d, 0, cz+Math.sin(a)*d));
                    }
                }
            }
            for (let i = 0; i < 8; i++) {
                personPositions.push(new BABYLON.Vector3((rand()-0.5)*50, 0, (rand()-0.5)*50));
            }

            function createPerson(pos, idx) {
                const root = new BABYLON.TransformNode("person"+idx, scene);
                root.position = pos.clone();
                const hs = 0.85 + rand()*0.35;
                const bw = rand()>0.5 ? 0.3 : 0.4;

                const cm = new BABYLON.StandardMaterial("pc"+idx, scene);
                const sh = 0.05 + rand()*0.08;
                cm.diffuseColor = new BABYLON.Color3(sh, sh, sh);
                cm.specularColor = BABYLON.Color3.Black();

                const sm = new BABYLON.StandardMaterial("ps"+idx, scene);
                const ss = 0.25 + rand()*0.2;
                sm.diffuseColor = new BABYLON.Color3(ss, ss*0.85, ss*0.8);
                sm.specularColor = BABYLON.Color3.Black();

                const body = BABYLON.MeshBuilder.CreateBox("bd"+idx, {width:bw, height:0.7*hs, depth:0.25}, scene);
                body.position.y = 0.85*hs; body.material = cm; body.parent = root;

                for (let s = -1; s <= 1; s += 2) {
                    const leg = BABYLON.MeshBuilder.CreateBox("lg"+idx+s, {width:0.14,height:0.8*hs,depth:0.16}, scene);
                    leg.position = new BABYLON.Vector3(s*0.1, 0.4*hs, 0); leg.material = cm; leg.parent = root;
                }
                for (let s = -1; s <= 1; s += 2) {
                    const arm = BABYLON.MeshBuilder.CreateBox("ar"+idx+s, {width:0.1,height:0.65*hs,depth:0.1}, scene);
                    arm.position = new BABYLON.Vector3(s*(bw/2+0.06), 0.75*hs, 0); arm.material = cm; arm.parent = root;
                }

                const hn = new BABYLON.TransformNode("hn"+idx, scene);
                hn.parent = root; hn.position.y = 1.4*hs;

                const head = BABYLON.MeshBuilder.CreateBox("hd"+idx, {width:0.22,height:0.26,depth:0.22}, scene);
                head.material = sm; head.parent = hn;

                const em = new BABYLON.StandardMaterial("pe"+idx, scene);
                em.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.85);
                em.emissiveColor = new BABYLON.Color3(0.35, 0.3, 0.15);
                em.specularColor = BABYLON.Color3.Black();

                for (let s = -1; s <= 1; s += 2) {
                    const eye = BABYLON.MeshBuilder.CreateSphere("ey"+idx+s, {diameter:0.05}, scene);
                    eye.position = new BABYLON.Vector3(s*0.06, 0.03, -0.11); eye.material = em; eye.parent = hn;
                    const pup = BABYLON.MeshBuilder.CreateSphere("pu"+idx+s, {diameter:0.028}, scene);
                    pup.position = new BABYLON.Vector3(s*0.06, 0.03, -0.125); pup.material = pupilMat; pup.parent = hn;
                }

                const mouth = BABYLON.MeshBuilder.CreatePlane("mo"+idx, {width:0.08,height:0.01}, scene);
                mouth.position = new BABYLON.Vector3(0, -0.06, -0.115); mouth.material = pupilMat; mouth.parent = hn;

                const shd = BABYLON.MeshBuilder.CreateGround("sh"+idx, {width:0.6,height:0.6}, scene);
                shd.position.y = 0.02;
                const shdm = new BABYLON.StandardMaterial("sm"+idx, scene);
                shdm.diffuseColor = BABYLON.Color3.Black(); shdm.alpha = 0.4;
                shd.material = shdm; shd.parent = root;

                return {
                    root, headNode: hn, eyeMat: em,
                    creepFactor: rand(),
                    headTiltOffset: (rand()-0.5)*0.3,
                    swaySpeed: 0.3+rand()*0.5,
                    swayAmount: 0.002+rand()*0.005
                };
            }

            for (let i = 0; i < personPositions.length; i++) {
                people.push(createPerson(personPositions[i], i));
            }

            // === GAME LOOP ===
            let time = 0, footstepTimer = 0, warningTimer = 0, warningActive = false;
            let stingerCooldown = 0, whisperCooldown = 0, closestDist = Infinity, breathPhase = 0;
            let mobileMoving = false;

            scene.registerBeforeRender(() => {
                const dt = engine.getDeltaTime() / 1000;
                time += dt;

                // Mobile input
                if (isMobile) {
                    camera.rotation.y += touchLookDX * 0.004;
                    camera.rotation.x += touchLookDY * 0.004;
                    camera.rotation.x = Math.max(-Math.PI/2.2, Math.min(Math.PI/2.2, camera.rotation.x));
                    touchLookDX = 0; touchLookDY = 0;

                    const spd = sprinting ? 0.15 : 0.08;
                    const has = Math.abs(touchMoveX) > 0.1 || Math.abs(touchMoveZ) > 0.1;
                    mobileMoving = has;
                    if (has) {
                        const fwd = camera.getDirection(BABYLON.Vector3.Forward());
                        fwd.y = 0; fwd.normalize();
                        const rt = camera.getDirection(BABYLON.Vector3.Right());
                        rt.y = 0; rt.normalize();
                        const mv = fwd.scale(-touchMoveZ).add(rt.scale(touchMoveX));
                        if (mv.length() > 0) { mv.normalize(); camera.position.addInPlace(mv.scale(spd)); }
                    }
                }

                const camPos = camera.position;

                // Flashlight follows camera
                flashlight.position.copyFrom(camPos);
                flashlight.direction = camera.getDirection(BABYLON.Vector3.Forward());

                // Footsteps
                const moving = isMobile ? mobileMoving : (camera._localDirection && (camera._localDirection.x !== 0 || camera._localDirection.z !== 0));
                if (moving) {
                    footstepTimer += dt * (sprinting ? 1.6 : 1);
                    if (footstepTimer > 0.45) { footstepTimer = 0; playFootstep(); }
                }

                // People look at player
                closestDist = Infinity;
                for (const p of people) {
                    const dx = camPos.x - p.root.position.x;
                    const dz = camPos.z - p.root.position.z;
                    const dist = Math.sqrt(dx*dx + dz*dz);
                    if (dist < closestDist) closestDist = dist;

                    p.root.rotation.y = Math.atan2(dx, dz);

                    const dy = camPos.y - (p.root.position.y + 1.4);
                    p.headNode.rotation.x = Math.atan2(dy, dist) * 0.5 + p.headTiltOffset;
                    p.root.rotation.z = Math.sin(time * p.swaySpeed) * p.swayAmount;

                    const glow = Math.max(0, 1-dist/20) * 0.5;
                    p.eyeMat.emissiveColor = new BABYLON.Color3(0.35+glow*1.0, 0.3+glow*0.3, 0.15);

                    if (p.creepFactor > 0.6 && dist > 3 && dist < 30) {
                        const fwd = camera.getDirection(BABYLON.Vector3.Forward());
                        const toP = new BABYLON.Vector3(dx,0,dz).normalize();
                        const dot = BABYLON.Vector3.Dot(new BABYLON.Vector3(fwd.x,0,fwd.z).normalize(), toP);
                        if (dot < 0.3) {
                            p.root.position.x -= (dx/dist) * 0.15 * dt;
                            p.root.position.z -= (dz/dist) * 0.15 * dt;
                        }
                    }
                }

                // Warning
                if (closestDist < 4) {
                    if (!warningActive) {
                        warningActive = true;
                        warningEl.style.display = "block";
                        const msgs = ["they're closer now","don't turn around","they see you","you can't leave","why are you here","we've been waiting","look at us"];
                        warningEl.textContent = msgs[Math.floor(Math.random()*msgs.length)];
                    }
                    warningTimer += dt;
                    warningEl.style.opacity = Math.sin(warningTimer*2)*0.5+0.5;
                } else { warningActive = false; warningTimer = 0; warningEl.style.opacity = 0; }

                // Stinger
                stingerCooldown -= dt;
                if (closestDist < 5 && stingerCooldown <= 0) {
                    const fwd = camera.getDirection(BABYLON.Vector3.Forward());
                    for (const p of people) {
                        const dx = p.root.position.x-camPos.x, dz = p.root.position.z-camPos.z;
                        const dist = Math.sqrt(dx*dx+dz*dz);
                        if (dist < 5) {
                            const dot = BABYLON.Vector3.Dot(new BABYLON.Vector3(fwd.x,0,fwd.z).normalize(), new BABYLON.Vector3(dx,0,dz).normalize());
                            if (dot > 0.85) { playScaryStinger(); stingerCooldown = 8; break; }
                        }
                    }
                }

                // Whispers
                whisperCooldown -= dt;
                if (whisperCooldown <= 0) {
                    if (closestDist < 15) playWhisper();
                    whisperCooldown = 5 + Math.random()*12;
                }

                // Flickering lights
                for (const sl of streetLights) {
                    if (Math.random() < 0.005) {
                        sl.light.intensity = 0;
                        sl.lampMat.emissiveColor = BABYLON.Color3.Black();
                    } else {
                        const fl = sl.baseIntensity + Math.sin(time*10+sl.light.position.x)*0.15;
                        sl.light.intensity = fl;
                        sl.lampMat.emissiveColor = new BABYLON.Color3(0.8*fl/2, 0.6*fl/2, 0.3*fl/2);
                    }
                }

                // Breathing
                breathPhase += dt * 1.2;
                camera.rotation.z = Math.sin(breathPhase) * 0.003;

                // Vignette
                const vi = Math.max(0.4, Math.min(0.9, 1-(closestDist-3)/15));
                vignette.style.background = `radial-gradient(ellipse at center, transparent ${55-vi*15}%, rgba(0,0,0,${vi*0.8}) 100%)`;

                // Dynamic fog
                scene.fogDensity = 0.012 + Math.max(0, (8-closestDist)/8)*0.008;
            });

            return scene;
        };

        const scene = createScene();

        // Start
        let gameStarted = false;
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            overlay.style.display = "none";
            crosshair.style.display = "block";
            vignette.style.display = "block";
            warningEl.style.display = "none";
            startAmbience();

            if (isMobile) {
                touchLayer.style.display = "block";
                sprintBtn.style.display = "flex";
                setupTouchControls();
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen().catch(() => {});
                }
            } else {
                canvas.requestPointerLock();
            }
        }

        overlay.addEventListener("click", startGame);
        overlay.addEventListener("touchend", (e) => { e.preventDefault(); startGame(); });

        if (!isMobile) {
            canvas.addEventListener("click", () => {
                if (!document.pointerLockElement) canvas.requestPointerLock();
            });
        }

        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
        window.addEventListener("orientationchange", () => setTimeout(() => engine.resize(), 200));
    </script>
</body>
</html>
